import{_ as o,c as i,a4 as t,o as a}from"./chunks/framework.NOSrbWr_.js";const g=JSON.parse('{"title":"一点哲学探讨","description":"","frontmatter":{"order":30,"title":"一点哲学探讨","math":true},"headers":[],"relativePath":"zh-Hans/book/misc/some-philosophy.md","filePath":"zh-Hans/book/misc/some-philosophy.md"}'),e={name:"zh-Hans/book/misc/some-philosophy.md"};function s(n,l,r,p,h,u){return a(),i("div",null,l[0]||(l[0]=[t('<h1 id="一点哲学探讨" tabindex="-1">一点哲学探讨 <a class="header-anchor" href="#一点哲学探讨" aria-label="Permalink to &quot;一点哲学探讨&quot;">​</a></h1><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>本页面充满了个人主观意见。请批判性阅读。</p></div><h2 id="you-could-have-invented-moran——魔然设计的逻辑" tabindex="-1">You could have invented Moran——魔然设计的逻辑 <a class="header-anchor" href="#you-could-have-invented-moran——魔然设计的逻辑" aria-label="Permalink to &quot;You could have invented Moran——魔然设计的逻辑&quot;">​</a></h2><p>魔然方案可以看作是沿着「智能拼音挂接」路子走到尽头的产物。具体来说，整个设计是从一个根本出发点开始，依逻辑不断推演得到的产物：</p><ul><li>想打词</li><li>为了打词轻松，词语编码应该以音码为主</li><li>为了词语码长短，以双拼为基础</li><li>为了词语编码空间尽可能大（双拼离散较差），选择不定长编码</li><li>为了不定长编码、兼容纯双拼、自动造词等功能，选择基于整句实现</li><li>为了解决整句的不确定性（在开启了用户词库时），设置固定简码</li><li>为了让简码的条反可以延续到整句，整句必须支持辅助码混输，并且整句用的辅助码必须和简码中用到的形码是一致的</li></ul><p>（其实上面每一步都值得写一小节来解释我的理由，不过这里就从略了。）</p><p>因此，整个魔然方案是完整的一体，各模式其实并不能分开来看。（除了辅筛是例外，它可以干净利落地拆成别的方案。）</p><h2 id="the-consistency-question——简繁字形的兼容性" tabindex="-1">The Consistency Question——简繁字形的兼容性 <a class="header-anchor" href="#the-consistency-question——简繁字形的兼容性" aria-label="Permalink to &quot;The Consistency Question——简繁字形的兼容性&quot;">​</a></h2><p>虽然上面说得一套一套的，但是魔然最初的出发点并不是「我觉得市面上的方案都不适合我！我要做一个最强的输入方案！」，而是一个小小的想法：「我要实验一下有没有方案可以同时兼容简繁字形！」——当时，我还在使用形码。</p><p>这个想法最初来自于 2022 年笔者对小鹤音形的尝试，发现虽然小鹤音形的码表是简体字，但是转换成繁体后，大部分字的编码其实不变。再加上考虑另一个极端：纯音码可以无缝兼容简繁字形。那是不是只要形的部分越少，兼容性就越好？</p><p>在初期尝试的过程中，我很快确立了部首优先的原则，即第三码应该是部首，不是拆字拆出来的第一个部件。这是因为它有很多我最初甚至没有预料到的好处：</p><ol><li>汉字中部首不出现在左边或上面的情况比想象中得多，可以提高三码离散。 <ol><li>如：「栽载哉」分别可以用 zlm zli zlk 输入，「墓幕暮慕募」分别可以用 mut muj muo mux mul 输入，「形型」分别是 xyp 和 xyt 而不会被「开」干扰</li></ol></li><li>部首和字义有强关联，拆字时往往不用思考字形，而是只需要想到字义，就能打出这个字。 <ol><li>如：垄（与土有关），攀（与手有关），忧（与心有关），暮（与日有关）</li></ol></li><li>部首往往可以恰好把一类字的不同字形归类在一起。 <ol><li>如：「劝勧劝」都是qrl，「忧忧」都是ybx</li></ol></li></ol><p>最初的魔然字词码表是同时容纳简体和繁体的，但是后来发现虽然整体上一致性很高，但是高频字中还是有不少字三码不一致。很多用户反馈自己不会繁体字，需要一个纯简体的码表，于是这才另外制作了简化字版本。——笔者虽然日常打简化字不少，但是依然使用繁体版，所以笔者认为只要您不抗拒繁体字（碰到三码不一致的情况时，您的第一反应是「又学到了」而不是「又被坑到了」），都可以先尝试尝试繁体版，也许有意外之喜呢。</p><p>因此，我认为关于简繁字形的实验本身已经完结了。结论是：有限度地成功。</p><h2 id="the-unreasonable-effectiveness——为什么魔然如此好用" tabindex="-1">The Unreasonable Effectiveness——为什么魔然如此好用 <a class="header-anchor" href="#the-unreasonable-effectiveness——为什么魔然如此好用" aria-label="Permalink to &quot;The Unreasonable Effectiveness——为什么魔然如此好用&quot;">​</a></h2><h3 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h3><p>如果您读了上两节，可能会注意到魔然一开始并不是为了「降低码长」「提高打字速度」等目标设计的，而是作者个人的一个小小实验品，单纯是为了实验音形码对简繁字形的兼容性。从另一个方面说，也是为了解决作者个人一个极小众的需求。</p><p>而其他设计，也都恰好只是这个需求催生来的——我只是希望音的部分够多（哪怕我长时间不用，也可以快速捡起来），而恰好我想少点选重，所以选择以「挂接用法」为蓝本而已。</p><p>当时（2023年初），我使用的是一款名为虎码的形码方案。我做魔然单纯是一个实验，打算在得到结论后，就回到虎码。唯一没想到的是，这个实验竟然相当成功，以至于我逐渐「乐不思虎」，在魔然扎根了，至今已经使用快 2 年。</p><p>但与之相对的是一个显然的悖论：自然码本身并不是一个追求性能的方案。单字重码率不低，词重更是不低。以通常视角来看，它不应该好用啊！</p><p>理论预言错得这么离谱，让我不得不做了一些分析：魔然究竟为什么好用？传统的评价指标到底「错」在哪？</p><h3 id="或许-我们选择的指标根本不对——一个新的输入法评价指标" tabindex="-1">或许，我们选择的指标根本不对——一个新的输入法评价指标 <a class="header-anchor" href="#或许-我们选择的指标根本不对——一个新的输入法评价指标" aria-label="Permalink to &quot;或许，我们选择的指标根本不对——一个新的输入法评价指标&quot;">​</a></h3><p>笔者认为，在全拼都能满足大部分用户的大背景下，汉字输入最重要的指标已经不是硬性的「码长」「确定性」等，而是一种（虚无缥缈的）「轻松感」「流畅感」，或者说，是实际输入中「<strong>输入法本身存在感的稀薄程度</strong>」。</p><blockquote><p>Note：我认为任何输入法方案作者都应该注意到这一点：如果输入法评测所用的硬性数据指标真的那么重要，那全拼根本不应该成为最流行的输入法。</p><p>因此，任何评价输入法的指标都应该接受<strong>全拼检验</strong>：你所预言的「好用程度」必须与全拼的流行程度一致。假设你选取的评价标准得到的结论是「全拼是最差的输入法」，那必须解释为什么你的预言和现实不符。</p></blockquote><p>如果以「输入法本身的存在感稀薄程度」为标准，我们可以立即注意到：</p><ol><li>音码（以智能拼音和智能双拼为代表）的存在感在选重时会显现出来。</li><li>形码的存在感在 (1) 拆字 (2) 选重 时显现出来。</li></ol><p>并且存在感会随时间累加：上面提到的事件如果耗时越长，存在感就越强。</p><p>因此，为了让输入更流畅，我们需要最小化拆字和选重的负担。下面我们来看看各输入法是怎么做的：</p><ol><li><strong>智能拼音</strong>：不断提高智能化程度，通过大量数据分析字词频率和关联，减少选字频率</li><li><strong>形码</strong>： <ol><li>针对拆字的存在感： <ol><li>强调训练高频字条反，从而降低拆字频率</li><li>设计更大的字根从而让拆字更直观，从而降低拆字用时</li></ol></li><li>针对选重的存在感：设计更大的字根、更怪的拆字、乱序分布字根、出简让全、出简不出全等方法，从而降低选重率 <ol><li>或者可以直接打纯单，这样就完全没有词重带来的存在感了</li></ol></li></ol></li></ol><p>那么魔然所属的<strong>双拼加形</strong>类别呢？</p><ol><li>针对拆字的存在感： <ol><li>通过设置简码，降低了拆字频率（一简和二简不需要拆字）</li><li>通过只取首末、字根音托，降低拆字耗时（思维负担的减少体现在时间缩短上）</li><li>通过置前两码为音码，拆字与输入音码可以同步进行，降低拆字的实际耗时</li></ol></li><li>针对选重的存在感： <ol><li>输入整句时，可以复用智能拼音的算法和一切成果</li><li>通过辅助码，可以降低选重的耗时</li><li>通过有策略地拆单，可以降低选重的频率</li></ol></li></ol><p>总的来说，双拼加形是对智能拼音的一个严格改进：它具有智能拼音的一切优势（从而有相同量级的选重频率），又有智能拼音所不具有的更多能力（这些能力可以降低选重频率），代价是一点学习成本。</p><p>在这里，我提出一个初步的量化方法：</p><p>存在感 = 选重频率 * 平均选重耗时 * w1 + 拆字频率 * 平均拆字耗时 * w2</p><p>（其中 w1 和 w2 是特定的加权系数，表示用户对这种存在感的厌恶程度：如果用户极度厌恶拆字（即提笔忘字还觉得这不是个事儿），那么他可以把 w2 设置为一个很大的数字。一般来说，为了讨论简便，不妨就设置 w1 = w2 = 1。）</p><p>「存在感」衡量了「仅仅因为输入法本身问题、导致用户额外付出的时间」（对不存在拆字和选重的方案也可以提出类似的指标），而在一个理想的输入法里，这个值应该是0。它并不衡量用户本身导致的输入错误问题（即键准不计入计算）。</p><p>事实上，在引入一些假设的前提下，存在感的确可以是 0：</p><ul><li>智能拼音用户在合适的文本上，可以做到 0。</li><li>形码用户对所有字全部条反，只打纯单，可以做到 0。</li><li>双拼加形用户预判所有重码，单字条反，可以做到 0。</li></ul><p>上面的公式中<strong>并没有</strong>出现码长、手感等很多输入法发烧友熟悉的指标。或许……这并不是一个巧合？事实上，我们可能都有过这样的体会：用过一个方案，觉得它非常顺手，但是绝对速度却不快；或者用过一个方案，绝对速度不低，但是怎么用怎么觉得不爽。</p><p>因此，我认为「存在感」可以较好地从<strong>用户侧终端</strong>衡量输入法的<strong>实际体感</strong>好用程度。每个输入法的存在感值甚至可以通过实验测量出来。</p><blockquote><ol><li><p>这个指标可以用来测试用户本身。试设想以下场景：</p><ol><li>某方案事实上是无理码，故在无外界帮助的情况下，拆字耗时可设想为无穷大，而用户不可避免地会碰到之前没打过的字，需要现拆，或</li><li>某拼音输入法每打一字都需要选字，且输入法的顺序完全错误，使得选字耗时极长</li></ol><p>则用户必然不会选择这样的方案。这意味着，用户必然存在一个「存在感耐受」的上限。<br> 上限可以用于选择最适合用户的方案：若用户通过估算或实验得到了自己的耐受上限，就可以选择存在感在该上限以下的、性能最佳的输入方案——也就是对自己来说最优的输入法。</p></li><li><p>这个指标也提供了一个评价方案的新维度。如果在任何情况下，方案A的绝对性能都较方案B更差，且存在感都更高，那么我们就有必要严肃地质疑这样的方案的意义为何了。</p></li><li><p>这个指标很有可能是不完备的。在本文中，我们假设 w1 和 w2 都只是用户本身的偏好，但这可能不对。例如，对拼音用户来说，选重是日常生活的一部分，所以碰到选重时不会有严重的抗拒心理；而对形码用户来说，任何一次非预期的选重都会带来严重的负反馈。这意味着上式中的 w1 和 w2 可能还与方案本身有关，而不只与用户有关。</p></li></ol></blockquote><h3 id="或许-收益与难度不成正比——为易学性正名" tabindex="-1">或许，收益与难度不成正比——为易学性正名 <a class="header-anchor" href="#或许-收益与难度不成正比——为易学性正名" aria-label="Permalink to &quot;或许，收益与难度不成正比——为易学性正名&quot;">​</a></h3><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>本节和下面的内容还未写完，不代表最终观点！</p></div><p>通常来说，我们会觉得收益与难度成正比。因此，一个追求「性能」的初学者会自然而然地忽视掉「易学」方案。但这种忽视对吗？</p><p>我们不妨假设一个人只要使用过一次某种信息（不论是字根键位还是读音），就永久条反了这个信息，从而得出一个最少的「形成条反」的时间下限：</p><ul><li><strong>四码形码</strong>：初次学习时间 <ul><li>= 编码时间 * <strong>总字数</strong></li><li>= 拆字时间 * <strong>总字数</strong> + 平均字根编码 * <strong>总字根数</strong><ul><li>可以进一步分成一二三简和全码</li></ul></li></ul></li><li><strong>音码</strong>：初次学习时间 <ul><li>= 编码时间 * 总字数 </li><li>= 读音时间 * 总字数 + 读音编码时间 * <strong>总音节数</strong></li><li>= 查询读音时间 * <strong>不会读音的字数</strong> + 读音编码时间 * <strong>总音节数</strong></li><li>≈ 读音编码时间 * <strong>总音节数</strong><ul><li>在常用字范畴上，可以认为「不会读音的字数 ≈ 0」</li></ul></li></ul></li><li><strong>音形码</strong>：初次学习时间 <ul><li>= 编码时间 * 总字数 </li><li>= (读音时间 + 判断简码时间) * <strong>总字数</strong> + 读音编码时间 * <strong>总音节数</strong> + 拆字时间 * <strong>三四码字数</strong> + 平均字根编码时间 * <strong>总字根数</strong></li><li>= 判断简码时间 * <strong>总字数</strong> + 查询读音时间 * <strong>不会读音的字数</strong> + 拆字时间 * <strong>三四码字数</strong> + 平均字根编码时间 * <strong>总字根数</strong></li><li>≈ 判断简码时间 * <strong>总字数</strong> + 读音编码时间 * <strong>总音节数</strong> + 拆字时间 * <strong>三四码字数</strong> + 平均字根编码时间 * <strong>总字根数</strong><ul><li>理由同音码</li></ul></li></ul></li></ul><p>为了让这个时间下限更加接近实际时间，可以引入「使用频度」 ——一个信息用得越频繁，越不容易忘。标记为 字根i编码时间/字根i使用频度。在假设频度完全均匀的情况下（最理想情况），字根越多，每字根频度越低，实际成本增长超过线性。不妨把实际成本作为编码要素数 N 的函数，且这个函数增长速度快于 kN，但很有可能小于 kN^2。换句话说，若字根数量翻倍，则学习成本会是原来的2倍还多，但不会到达4倍。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>上式中的 / 表示频度越低，实际花费的时间越高。但实际生活中很有可能并不是线性关系，而可能是其他某种函数关系。这里提示读者不要把 / 当作真正的「除法」，只作为一种简写。</p></div><p>经过估算，可以得到一个粗糙的结论：</p><ul><li>难度一般与有关，</li><li>一般而言，音形码难度低于形码，高于音码 <ul><li>在特定情况下，</li></ul></li><li>但是当我们考虑词语输入时，音形码难度低于</li></ul><h3 id="或许-重码率没那么重要——双拼加形的特殊性" tabindex="-1">或许，重码率没那么重要——双拼加形的特殊性 <a class="header-anchor" href="#或许-重码率没那么重要——双拼加形的特殊性" aria-label="Permalink to &quot;或许，重码率没那么重要——双拼加形的特殊性&quot;">​</a></h3><p>TODO</p><h3 id="打字速度到哪才是头-——论确定性与性能" tabindex="-1">打字速度到哪才是头？——论确定性与性能 <a class="header-anchor" href="#打字速度到哪才是头-——论确定性与性能" aria-label="Permalink to &quot;打字速度到哪才是头？——论确定性与性能&quot;">​</a></h3><p>TODO</p><h3 id="自然码-魔然本身的特有优势" tabindex="-1">自然码/魔然本身的特有优势 <a class="header-anchor" href="#自然码-魔然本身的特有优势" aria-label="Permalink to &quot;自然码/魔然本身的特有优势&quot;">​</a></h3><p>TODO</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>TODO</p>',58)]))}const d=o(e,[["render",s]]);export{g as __pageData,d as default};
